#include QMK_KEYBOARD_H


/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
 */

 // Home row mods
 // Base Layer
#define H_A LGUI_T(KC_A)
#define H_S LALT_T(KC_S)
#define H_D LSFT_T(KC_D)
#define H_F LCTL_T(KC_F)
#define H_J LCTL_T(KC_J)
#define H_K RSFT_T(KC_K)
#define H_L LALT_T(KC_L)
#define H_SC RGUI_T(KC_SCLN)
// Symbol Layer
#define H_EX LGUI_T(KC_EXLM)
#define H_MIN LALT_T(KC_MINS)
#define H_PLUS LSFT_T(KC_PLUS)
#define H_EQ LCTL_T(KC_EQL)
#define H_LBR LCTL_T(KC_LCBR)
#define H_RBR RSFT_T(KC_RCBR)
#define H_GRV LALT_T(KC_GRV)
#define H_QUES RGUI_T(KC_QUES)
// Number Layer
#define H_F4 LALT_T(KC_F4)
#define H_F5 LSFT_T(KC_F5)
#define H_F6 LCTL_T(KC_F6)
#define H_4 LCTL_T(KC_4)
#define H_5 RSFT_T(KC_5)
#define H_6 LALT_T(KC_6)
#define H_0 RGUI_T(KC_0)
// Navigation Layer
#define H_SWL RSFT_T(LGUI(KC_LEFT))
#define H_SWR LCTL_T(LGUI(KC_RGHT))
#define H_TABL LCTL(LSFT(KC_LBRC))
#define H_TABR LCTL(LSFT(KC_RBRC))

#define KC_TALK MEH(KC_F13) // talk
#define KC_PTT HYPR(KC_F1) // Push to talk
#define KC_VA HYPR(KC_F2) // Voice activation
#define KC_MU HYPR(KC_F3) // Mute
#define KC_AE RALT(KC_Q)
#define KC_OE RALT(KC_P)
#define KC_UE RALT(KC_Y)
#define KC_SS RALT(KC_S)
#define LSHIF OSM(MOD_LSFT)
#define RSHIF OSM(MOD_RSFT)
#define COPY LCTL(KC_C)
#define PASTE LCTL(KC_V)
#define UNDO LCTL(KC_Z)
#define PIPE S(KC_BSLS)
#define DQUOT S(KC_QUOT)

#define EN2 LT(3, KC_ENT)
#define SPA3 LT(4, KC_SPC)

// Windows presets
#define KC_TASK LGUI(KC_TAB)
#define KC_FLXP LGUI(KC_E)

enum custom_keycodes {
  ARROW = SAFE_RANGE,
  UPDIR
};

bool process_record_user(uint16_t keycode, keyrecord_t* record) {
  switch (keycode) {
    case ARROW:
      if (record->event.pressed) {
        SEND_STRING("->");
      }
      return false;
	case UPDIR:
		if (record->event.pressed) {
			SEND_STRING("../");
		}
		return false;
	case H_EX:
            if (record->tap.count && record->event.pressed) {
                tap_code16(KC_EXLM); 
                return false; 
            }
            break;
	case H_PLUS:
            if (record->tap.count && record->event.pressed) {
                tap_code16(KC_PLUS); 
                return false;        
            }
            break;
	case H_LBR:
            if (record->tap.count && record->event.pressed) {
                tap_code16(KC_LCBR); 
                return false;        
            }
            break;
	case H_RBR:
            if (record->tap.count && record->event.pressed) {
                tap_code16(KC_RCBR); 
                return false;        
            }
            break;
	case H_QUES:
            if (record->tap.count && record->event.pressed) {
                tap_code16(KC_QUES); 
                return false;        
            }
            break;
    case H_SWL:
            if (record->tap.count && record->event.pressed) {
                tap_code16(LGUI(KC_LEFT)); 
                return false;        
            }
            break;
    case H_SWR:
            if (record->tap.count && record->event.pressed) {
                tap_code16(LGUI(KC_RGHT));
                return false;        
            }
            break;
  }
  return true;
}

enum layer_names {
	_WIN_DEFAULT,
	_TYPING,
	_SYMBOL,
	_NUMBER,
	_NAVIGATION
};

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
	[_WIN_DEFAULT] = LAYOUT(
				TG(5),   KC_1,  KC_2,    KC_3,    KC_4,    KC_5,        				   KC_6,    KC_7,    KC_8,    KC_9,   KC_0,    KC_MU, 
				KC_ESC,  KC_Q,  KC_W,    KC_E,    KC_R,    KC_T, 				 	       KC_Y,    KC_U,    KC_I,    KC_O,   KC_P,    CW_TOGG, 
				KC_TAB,  H_A,   H_S,     H_D,     H_F,     KC_G, 					       KC_H,    H_J,     H_K,     H_L,    H_SC,    KC_ESC,
				LSHIF,   KC_Z,  KC_X,    KC_C,    KC_V,    KC_B,  KC_MUTE,		 KC_MUTE,  KC_N,  KC_M,    KC_COMM, KC_DOT, KC_SLSH, KC_DEL, 
				            	COPY,    PASTE,   UNDO,    OSL(2),EN2,     KC_BSPC, SPA3,  KC_TALK, KC_PTT,  KC_VA
	),
	[_TYPING] = LAYOUT(
				_______, _______,  _______, _______, _______, _______,        		    _______, _______, _______, _______, _______, _______, 
				KC_ESC,  KC_Q,     KC_W,    KC_E,    KC_R,    KC_T, 				 	         KC_Y,    KC_U,    KC_I,    KC_O,    KC_P,    KC_UE, 
				KC_TAB,  H_A,      H_S,     H_D,     H_F,     KC_G, 					         KC_H,    H_J,     H_K,     H_L,     KC_OE,    KC_AE,
				LSHIF,   KC_Z,     KC_X,    KC_C,    KC_V,    KC_B,   KC_MUTE, XXXXXXX, KC_N,   KC_M,    KC_COMM, KC_DOT,  KC_SLSH, RSHIF, 
								   COPY,    PASTE,   KC_SS,   OSL(2), EN2,     KC_BSPC, SPA3,   KC_TALK, KC_PTT,  KC_VA
	),
	[_SYMBOL] = LAYOUT(
				_______,  _______,  _______,    _______,    _______,    _______,        			_______,   _______, _______, _______, _______, _______, 
				_______,  KC_LABK, KC_RABK,     KC_QUOT,    KC_DQUO,    ARROW,                      KC_AMPR,   KC_LPRN, KC_RPRN, KC_PERC, KC_DLR,  KC_UE,
				_______,  H_EX,    H_MIN,       H_PLUS,     H_EQ,       KC_HASH, 			        KC_PIPE,   H_LBR,   H_RBR,   H_GRV,   H_QUES,  TG(1),
				_______,  KC_CIRC, KC_SLSH,     KC_ASTR,    KC_BSLS,    UPDIR,    KC_MUTE, XXXXXXX, KC_TILD,   KC_LBRC, KC_RBRC, KC_UNDS, KC_AT,   RALT(KC_5),
				            	   _______,    _______,    _______,    _______,  _______,  _______, _______,   _______, _______, _______
	),
	[_NUMBER] = LAYOUT(_______,  _______,  _______,    _______,  _______,  _______,        			 _______,  _______, _______, _______, _______, _______, 
				 _______,  _______,  KC_F7,      KC_F8,    KC_F9,    KC_F10,                     KC_COMM,  KC_7,    KC_8,    KC_9,    _______, _______,
				 _______,  KC_LGUI,  H_F4,       H_F5,     H_F6,     KC_F11, 		             KC_DOT,   H_4,     H_5,     H_6,     H_0,     _______, 
				 _______,  _______,  KC_F1,      KC_F2,    KC_F3,    KC_F12,   KC_MUTE, XXXXXXX, _______,  KC_1,    KC_2,    KC_3,    _______, _______,
				            	     _______,    _______,  _______,  _______,  _______, _______, _______,  _______, _______, _______
	),
	[_NAVIGATION] = LAYOUT(
				_______,  _______,  _______,    _______,     _______,     _______,        			 _______,   _______, _______, _______, _______, _______, 
				_______,  _______,  _______,    MEH(KC_F14), MEH(KC_F15), _______,                   _______,   KC_HOME, KC_UP,   KC_END,  _______, _______,
				_______,  KC_LGUI,  KC_LALT,    H_SWL,       H_SWR,       _______, 			         KC_PGUP,   KC_LEFT, KC_DOWN, KC_RGHT, _______, _______,
				_______,  _______,  _______,    H_TABL,      H_TABR,      _______, KC_MUTE, XXXXXXX, KC_PGDN,   _______, _______, _______, _______, _______,
				            	    _______,    _______,     _______,     _______, _______, _______, _______,   _______, _______, _______
	)

};

#if defined(ENCODER_ENABLE) && defined(ENCODER_MAP_ENABLE)
const uint16_t PROGMEM encoder_map[][NUM_ENCODERS][NUM_DIRECTIONS] = {

};
#endif // defined(ENCODER_ENABLE) && defined(ENCODER_MAP_ENABLE)

/* The encoder_update_user is a function.
 * It'll be called by QMK every time you turn the encoder.
 *
 * The index parameter tells you which encoder was turned. If you only have
 * one encoder, the index will always be zero.
 * 
 * The clockwise parameter tells you the direction of the encoder. It'll be
 * true when you turned the encoder clockwise, and false otherwise.
 */
bool encoder_update_user(uint8_t index, bool clockwise) {
  /* With an if statement we can check which encoder was turned. */
  if (index == 0) { /* First encoder */
  /* Encoder not soldered*/
  } 
  if (index == 1) { /* First encoder */
	switch(biton32(layer_state)){
             case 2:
                if (clockwise){
                    tap_code(KC_VOLU);
                } else{
                    tap_code(KC_VOLD);
                }
                break;
            default:
                if (clockwise){
                    tap_code(KC_WH_U);
                } else{
                    tap_code(KC_WH_D);
                }
                break;
      }
  }
  return false;
}


